<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    
</body>
<script>
    // 1、
    /*let abc="abc";
    let abc="cab";
    console.log(abc)*/
    // 报错——let不能重复声明

    // 2、
    let { baz } = { foo: 'baz', bar: 'bbb' };
    console.log(baz)    //undefined

    // 3、
    /*let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
    console.log(baz)    //aaa
    console.log(foo)    //报错
    */
    
    // 问答题
    // 1. 以下代码控制台分别打印什么？
    function move({x, y} = { x: 0, y: 0 }) {
       return [x, y];
    }
     
    console.log(move({x: 3, y: 8}));    //3,8
    console.log(move({x: 3}));          //3,undefined
    console.log(move({}));              //undefined,undefined
    console.log(move());                //[0,0]
    
    // 2. 以下代码控制台分别打印什么？
    let o1 = { a: 1 };
    let o2 = { b: 2 };
    o2.__proto__ = o1;
    let { ...o3 } = o2;
    
    console.log(o3)     //{b:2}
    console.log(o3.a)   //undefined 

    // 3. 以下代码控制台分别打印什么？
    //includes() 方法用来判断一个数组是否包含一个指定的值，如果是返回 true，否则false。
    //1）第一个参数是要查找的元素
    //2）第二个参数表示搜索的起始位置，默认为 0 。
        //如果第二个参数为负数，则表示倒数的位置，
        //如果这时它大于数组长度（比如第二个参数为
        // -4 ，但数组长度为 3 ），则会重置为从 0 开始。
    console.log([1, 2, 3].includes(3, 3));      //false
    console.log([1, 2, 3].includes(3, -1));     //true

    // 4. 以下代码控制台分别打印什么？
    const [first, a,...rest] = ["foo"];
    console.log(first)  //foo
    console.log(a)      //undefined
    console.log(rest)   //[]

    //5. 以下代码控制台打印什么？
    function fn() {
       return "Hello World";
    }
    console.log(`foo ${fn()} bar`)
    // foo Hello World bar

    // 6. 以下代码控制台分别打印什么？
    let x = 1;
    let y = 2;
                
    console.log(`${x} + ${y} = ${x + y}`) // 1+2=3
    console.log(`${x} + ${y * 2} = ${x + y * 2}`) // 1+4=5
                
    let obj = {x: 1, y: 2};
    console.log(`${obj.x + obj.y}`) // 3
                



    // 异步请求：
    // 1. 以下代码控制台分别打印什么？
    // let promise = new Promise(function(resolve, reject) {
    //     console.log('Promise'); //Promise
    //     resolve('成功');
    // });

    // promise.then(function() {
    //     console.log('resolved.');   //resolved.
    // });
    // console.log('Hi!'); //Hi!
    // 先输出88；输出96；输出93

    // 2. 以下代码控制台分别打印什么？
    // new Promise((resolve, reject) => {
    //    resolve(1);
    //    console.log(2);  //2
    // }).then(r => {
    //    console.log(r);  //1
    // });

    // 3. 以下代码控制台打印什么？
    // 函数f内部return命令返回的值，会被then方法回调函数接收到
    // async function f() {
    //    return await 123;
    // }
    // f().then(v => console.log(v))   //123

    // 4. 以下代码控制台分别打印什么？
    // async function f() {
    //     await Promise.reject('出错了').catch(e => console.log(e));  //出错了
    //     return await Promise.resolve('hello world');
    // } 
    // f().then(v => console.log(v))   //hello world



    // 面向对象
    // 1. 以下代码控制台分别打印什么？
    // hasOwnProperty()方法返回一个布尔值，判断对象是否包含特定的自身（非继承）属性。
    // Point.prototype.constructor === Point // true
    class Point {
        constructor(x, y) {
            this.x = x;
            this.y = y;
        }
        toString() {
            return '(' + this.x + ', ' + this.y + ')';
        }
    }
    var point = new Point(2, 3);
    console.log(point.toString())   //(2,3)
    console.log(point.hasOwnProperty('x'))  //true
    console.log(point.hasOwnProperty('y'))  //true
    console.log(point.hasOwnProperty('toString'))   //false
    console.log(point.__proto__.hasOwnProperty('toString')) //true

    // 2. 以下代码控制台分别打印什么？
    // 遍历器
    class Foo {
        constructor(...args) {
            this.args = args;
        }
        * [Symbol.iterator]() {
            for (let arg of this.args) {
                yield arg;
            }
        }
    }
    for (let x of new Foo('hello', 'world')) {
        console.log(x); //hello  //world
    }

    // 3. 以下代码控制台打印什么？
    // 继承
    class A {
        constructor() {
            this.x = 1;
        }
        print() {
            console.log(this.x);    //2
        }
    }
    class B extends A {
        constructor() {
            super();
            this.x = 2;     
        }
        m() {
            super.print();  
        }
    }
    let b = new B();
    console.log(b.m())  //undefined

</script>
</html>